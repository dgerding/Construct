
There are 3 things that collaborate to make your sensor logic work: SensorHosts, Construct Studio, and the Construct Sensor API.

The sensor that you write can be automatically deployed and managed so long as the target is running a sensor host. There are different types of sensor hosts - windows, ios, android, etc. and the sensor host type that you are using must be defined within the declaration for your sensor. Back to that in a minute.

Your sensor is a class that inherits the Construct.Sensors.Sensor class. The constructor for that class consists of the method used for communication with the sensor (HTTP, NetNamedPipes, TCP), a set of commandline parameters, the sensor type, and a dictionary defining a mapping of various other types. Note that the "commandline parameters" that are meant to be input are automatically sent by the sensor host when your sensor is starting up. Therefore, you define the inputs for every parameter to the base constructor other than those commandline parameters.

Just about everything within construct has a GUID, and these GUIDs are used to refer to other things. A common noun is "type", where there are types of types of types that are used. You must define GUIDs for the following types:
--- Type of sensor
--- The payload that is being sent by that sensor
--- The type of data that will be in the payload

These GUIDs must be defined by your sensor, and these are obtained by Construct in the construct.xml file that will accompany a sensor. This defines the various properties of the sensor and is required. The GUIDs for the types that I mentioned earlier must be generated by the developer. There is no special GUID that you're supposed to use for your sensor, except in the case of:

--- Sensor Host Types (there are specific GUIDs for Windows, Mac, iOS, etc., which can be found in the Construct SQL DB: Databases->Construct3->Tables->dbo.Sources_SensorHostType. Be warned: If you're going to look at this, pay attention to the ID column, not the ParentID column. I didn't pay attention at first and got really confused.)

--- Parent Sensor Types (IIRC, there's always supposed to be a parent sensor and there is a single GUID that describes a universal sensor parent that can be used. Assuming this is correct, the GUID I've been using to represent this is "5C11FBBD-9E36-4BEA-A8BE-06E225250EF8", and you can find that it's also embedded in the ConstructMetadataGenerator.)

The sensor generator thingy (I named it incorrectly) will handle a lot of this work for you and instead provide you the same work but with some automation and a UI. The sensor generator assumes that the payload you send will be a class that you've defined somewhere. Assuming this is true, you'd open up a DLL assembly defining your payload class, and the generator would automatically create an XML sensor definition representative of the type that you provided. Note that a payload MUST be a flat type, meaning no objects within objects. Only values supported by the construct server being ran can be sent over a payload. The available types can be found at: Databases->Construct3->Tables->dbo.Types_DataType, the relevant column is FullName.

A sensor can emit multiple types of payloads. Each payload must be defined within the XML sensor definition, and the payload (when sent) will be transfered along with the GUID of the datatype that it belongs to. Once it reaches Construct, the server will be able to pull out data based on what is in the sensor definition.

---------------------------------------------------
...

Once you have your sensor built and the XML definition is written, place the executable (and DLLs it depends on) as well as the construct.xml file in a ZIP whose name is formatted as: <SensorName>.<SensorTypeGuid>.<VersionNumber>
The naming of the file is important since there is currently a temporary system for parsing the sensors based on their package name. VersionNumber cannot be formatted as i.e. 1.0.0.0 since periods are used as delimiters.

Move the ZIP file onto Daisy at: C:/Construct/Sensors and start up construct studio. (Note that there is currently a package-and-deploy batch file that automatically ZIPs the bin/Debug folder into an archive that's been named specifically for my sensor. You can make a modified version of this for your own convenience.) When you're in the sources pane, you'll be shown an input box for the download URI and the package file name to deploy the sensor. The download URI is just "daisy"/"daisy.colum.edu"/"<daisy's IP>" (if one doesn't work, try the other. name resolution is weird) and the package file name is the full name of the ZIP that you placed on Daisy. Clicking Install should deploy the sensor to the sensor host that you specify, and you will be allowed to load/unload/start/stop the sensor.