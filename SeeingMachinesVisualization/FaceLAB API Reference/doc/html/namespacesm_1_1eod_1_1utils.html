<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Seeing Machines CoreData API: sm::eod::utils Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.0 -->
<div class="nav">
<a class="el" href="namespacesm.html">sm</a>::<a class="el" href="namespacesm_1_1eod.html">eod</a>::<a class="el" href="namespacesm_1_1eod_1_1utils.html">utils</a></div>
<h1>sm::eod::utils Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Useful functions for interpreting <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">EngineOutputData</a> objects. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html">GeomUtilsError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class to indicate errors in geom util functions.  <a href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class to indicate errors in outputdata util functions.  <a href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Geometry Utility Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<b>PITCH</b> =  0, 
<br>
&nbsp;&nbsp;<b>YAW</b> =  1
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<b>X_AXIS</b> =  0, 
<br>
&nbsp;&nbsp;<b>Y_AXIS</b> =  1, 
<br>
&nbsp;&nbsp;<b>Z_AXIS</b> =  2
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#224b9163917ac32fc95a60d8c1eec3aa">Direction</a> { <br>
&nbsp;&nbsp;<b>X_DIRECTION</b> =  0, 
<br>
&nbsp;&nbsp;<b>Y_DIRECTION</b> =  1, 
<br>
&nbsp;&nbsp;<b>Z_DIRECTION</b> =  2
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#75e2dd6d539b13564c7cd544e3119cda">coefficientsOfRaysClosestApproach</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin2, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction2, float &amp;coefficient1_out, float &amp;coefficient2_out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#0e98f480ebeee67ccf07538da5af120f">crossProduct</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#ee434ad4400e5f14e22ae182cb2f2ecd">directionFromPitchYaw</a> (const <a class="el" href="namespacesm_1_1eod.html#839d4aba62f000fcedbad80d71f505d7">fStdVector2</a> &amp;pitch_yaw)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector&lt;<br>
 float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#09062203befa6bb1ad7db0537cba9dbc">eulerAnglesToRotationMatrix</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;euler_angles)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesm_1_1eod.html#7fd9102b624957cdd32629d206faa8e9">dStdVector4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#f64c7820dac7832041ec67aae188b852">fromEulerAngles</a> (const <a class="el" href="namespacesm_1_1eod.html#8f3c6523d26c72f00fd9c0e2319274a0">dStdVector3</a> &amp;euler_angles)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#b920c3f69553c65a8ba4eccfff14d1d6">innerProduct</a> (const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#3a31b6978f9f135e1b768de30cd4aa10">length</a> (const std::vector&lt; float &gt; &amp;direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#006cef3006962e26346539e576ee9d2e">operator *</a> (float factor, const std::vector&lt; float &gt; &amp;direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#080d6a608ee93d86cfc0447f928bf613">operator+</a> (const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#6e2a588ccfbf3edf9a256ac6b8a0df8c">operator-</a> (const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#1431e95fd081fe9f95f368845e533940">operator-</a> (const std::vector&lt; float &gt; &amp;direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#839d4aba62f000fcedbad80d71f505d7">fStdVector2</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#59f41b5772abf4cf0dafb67ba89a9a61">pitchYawFromDirection</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#9c262f203be61a78d049717d1b21b30f">pointsOfRaysClosestApproach</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin2, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction2, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;closest_point1_out, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;closest_point2_out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#3120e842481fda5b1f0d8131448808a4">rayIntersectionPoint</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;origin2, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#a0c37825beb7a2ef090965dd27708037">rayPlaneIntersect</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_origin, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;plane_top_left, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;plane_top_right, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;plane_bottom_left, <a class="el" href="namespacesm_1_1eod.html#839d4aba62f000fcedbad80d71f505d7">fStdVector2</a> &amp;plane_intersect, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;world_intersect)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#04bd1028b33e36cd2e4e921072ad1064">rotMatrixToDirection</a> (std::vector&lt; std::vector&lt; float &gt; &gt; rotation_matrix, <a class="el" href="namespacesm_1_1eod_1_1utils.html#224b9163917ac32fc95a60d8c1eec3aa">Direction</a> dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#f62f0e544cdf38384157b6cb44db8ee3">rotMatrixToEulerAngles</a> (const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;rotation_matrix)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesm_1_1eod.html#8f3c6523d26c72f00fd9c0e2319274a0">dStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#90c052ce38c95701b22cc301b3ba1854">toEulerAngles</a> (const <a class="el" href="namespacesm_1_1eod.html#7fd9102b624957cdd32629d206faa8e9">dStdVector4</a> &amp;quaternion)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#ca63a036ef1dedbbf36070bcfa108ca8">unitVector</a> (const std::vector&lt; float &gt; &amp;direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#dcbb94eeb4dd82aaaedf6833bab656b6">vectorIntersectionAngle</a> (const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction1, const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;direction2)</td></tr>

<tr><td colspan="2"><br><h2>EngineOutputData Utility Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#ed0485076d58a6953f8afb321689cf3d">MAX_GAZE_VERGENCE_DISTANCE</a> = 1.5f</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#45988d64bcb955846f179a5e2a292404">bestGazeRay</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_origin, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#eca67a8e6e997e0d476bcac31f9e91a1">bestGazeRay</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_origin, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bf997554902dc77cf65eda4ff8ce711"></a><!-- doxytag: member="sm::eod::utils::convertLogToText" ref="1bf997554902dc77cf65eda4ff8ce711" args="(const std::string &amp;input_file, const std::string &amp;output_file)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>convertLogToText</b> (const std::string &amp;input_file, const std::string &amp;output_file)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#fee8796085c426e76b8849cdc399c505">convertLogToText</a> (const std::wstring &amp;input_file, const std::wstring &amp;output_file)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#f3c9ca5f188b768fb6c69b333ba6c1ab">cyclopsVector</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#5d8e54a7ba8fd2bf22f3305f7a2b0f16">cyclopsVector</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html#b4a855ab0be6004dd4e37af0606881fb">EngineOutputData::FrameNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#59ad083417373e086ee93ca208c6b82f">frameNumber</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#4b36da673b2cf8a78d3eb5ced1d20fb7">gazeVergenceAngle</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#a2aba5c1caead40163b7857a712e4c76">gazeVergenceAngle</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#d527bdf75162449ab99b11afdd4ed3b0">gazeVergenceDistance</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#550caa8097e6761782cef9bc0a254b8b">gazeVergenceDistance</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#5b888a3ce0e071680e63fa5a79b07a93">gazeVergencePoint</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#354de619cae8e28a6ed28b260e9c7a0e">gazeVergencePoint</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66ef9d577f536cb9ca1dfd772f844404"></a><!-- doxytag: member="sm::eod::utils::isTracking" ref="66ef9d577f536cb9ca1dfd772f844404" args="(const sm::eod::EngineOutputData &amp;eod)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isTracking</b> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;eod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#35a932c49a35d08f510ec833536abcb6">isTracking</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;eod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#c758cfda1eb8caa7f77103db8a0c076a">mergedGazeRay</a> (const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_origin, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesm_1_1eod_1_1utils.html#aa4cdc2800eb7315f15cbde1f628b1c9">mergedGazeRay</a> (<a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;data, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_origin, <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> &amp;ray_direction)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="0411cd49bb5b71852cecd93bcbf0ca2d"></a><!-- doxytag: member="sm::eod::utils::@7" ref="0411cd49bb5b71852cecd93bcbf0ca2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indexes into arrays containing a pitch and yaw value. 
<p>

<p>
Definition at line <a class="el" href="geomutils_8h-source.html#l00019">19</a> of file <a class="el" href="geomutils_8h-source.html">geomutils.h</a>.
</div>
</div><p>
<a class="anchor" name="bed82baf7f470b522273a3e37c24c600"></a><!-- doxytag: member="sm::eod::utils::@8" ref="bed82baf7f470b522273a3e37c24c600" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indexes into arrays containing a 3D direction vector. 
<p>

<p>
Definition at line <a class="el" href="geomutils_8h-source.html#l00026">26</a> of file <a class="el" href="geomutils_8h-source.html">geomutils.h</a>.
</div>
</div><p>
<a class="anchor" name="224b9163917ac32fc95a60d8c1eec3aa"></a><!-- doxytag: member="sm::eod::utils::Direction" ref="224b9163917ac32fc95a60d8c1eec3aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesm_1_1eod_1_1utils.html#224b9163917ac32fc95a60d8c1eec3aa">Direction</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to extract a direction vector from a rotation matrix in rotMatrixToDirection. 
<p>

<p>
Definition at line <a class="el" href="geomutils_8h-source.html#l00034">34</a> of file <a class="el" href="geomutils_8h-source.html">geomutils.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="45988d64bcb955846f179a5e2a292404"></a><!-- doxytag: member="sm::eod::utils::bestGazeRay" ref="45988d64bcb955846f179a5e2a292404" args="(const sm::eod::EngineOutputData &amp;data, fStdVector3 &amp;ray_origin, fStdVector3 &amp;ray_direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sm::eod::utils::bestGazeRay           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="eca67a8e6e997e0d476bcac31f9e91a1"></a><!-- doxytag: member="sm::eod::utils::bestGazeRay" ref="eca67a8e6e997e0d476bcac31f9e91a1" args="(sm::eod::EngineOutputData &amp;data, fStdVector3 &amp;ray_origin, fStdVector3 &amp;ray_direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sm::eod::utils::bestGazeRay           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the best quality gaze ray in the <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">EngineOutputData</a>. 
<p>
Returns the gaze ray corresponding to the eye with the best Gaze Quality Level If both eyes have the same GQL, the gaze ray for the right eye is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">EngineOutputData</a> to extract the best gaze ray from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ray_origin</em>&nbsp;</td><td>contains the origin of the best gaze ray after this function has finished executing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ray_direction</em>&nbsp;</td><td>contains the origin of the best gaze ray after this function has finished executing </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The eye ID corresponding to the eye with the best gaze ray </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>gaze data must be present and the gaze quality level for at least one eye must be greater than NO_TRACKING </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if gaze ray cannot be computed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="75e2dd6d539b13564c7cd544e3119cda"></a><!-- doxytag: member="sm::eod::utils::coefficientsOfRaysClosestApproach" ref="75e2dd6d539b13564c7cd544e3119cda" args="(const fStdVector3 &amp;origin1, const fStdVector3 &amp;direction1, const fStdVector3 &amp;origin2, const fStdVector3 &amp;direction2, float &amp;coefficient1_out, float &amp;coefficient2_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm::eod::utils::coefficientsOfRaysClosestApproach           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>coefficient1_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>coefficient2_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the coefficients for the ray's basis vectors for the points of closest approach. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>origin1</em>&nbsp;</td><td>The origin of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction1</em>&nbsp;</td><td>The direction vector of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin2</em>&nbsp;</td><td>The origin of the second ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction2</em>&nbsp;</td><td>The direction vector of the second ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coefficient1_out</em>&nbsp;</td><td>Return the coefficient for ray1 for point of closest approach </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coefficient2_out</em>&nbsp;</td><td>Return the coefficient for ray2 for point of closest approach </td></tr>
  </table>
</dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>origin1, direction1, origin2, direction2 must be in 3 dimensions </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html">GeomUtilsError</a></em>&nbsp;</td><td>if the two rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fee8796085c426e76b8849cdc399c505"></a><!-- doxytag: member="sm::eod::utils::convertLogToText" ref="fee8796085c426e76b8849cdc399c505" args="(const std::wstring &amp;input_file, const std::wstring &amp;output_file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm::eod::utils::convertLogToText           </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>input_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>output_file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a binary logfile into text format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input_file</em>&nbsp;</td><td>path to the binary file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_file</em>&nbsp;</td><td>path to the text output file that will contain the converted data. If the file already exists, it is overwritten. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if an error occured when converting the file </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e98f480ebeee67ccf07538da5af120f"></a><!-- doxytag: member="sm::eod::utils::crossProduct" ref="0e98f480ebeee67ccf07538da5af120f" args="(const fStdVector3 &amp;direction1, const fStdVector3 &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::crossProduct           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The cross product of the two vectors passed in </dd></dl>

<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vectors are of 3 dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3c9ca5f188b768fb6c69b333ba6c1ab"></a><!-- doxytag: member="sm::eod::utils::cyclopsVector" ref="f3c9ca5f188b768fb6c69b333ba6c1ab" args="(const sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::cyclopsVector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d8e54a7ba8fd2bf22f3305f7a2b0f16"></a><!-- doxytag: member="sm::eod::utils::cyclopsVector" ref="5d8e54a7ba8fd2bf22f3305f7a2b0f16" args="(sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::cyclopsVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The cyclops (head-pose normal) vector for the output data <em>data</em> </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>head data must be present </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee434ad4400e5f14e22ae182cb2f2ecd"></a><!-- doxytag: member="sm::eod::utils::directionFromPitchYaw" ref="ee434ad4400e5f14e22ae182cb2f2ecd" args="(const fStdVector2 &amp;pitch_yaw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::directionFromPitchYaw           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector2 &amp;&nbsp;</td>
          <td class="paramname"> <em>pitch_yaw</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a normalized vector [X, Y, Z] in the direction given by the [PITCH, YAW] angles in <em>pitch_yaw</em>. </dd></dl>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pitch_yaw</em>&nbsp;</td><td>The pitch and yaw angles in some coordinate frame. Pitch corresponds to element 0. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this function always uses the negative z convention </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>pitch_yaw must have two elements </dd></dl>

</div>
</div><p>
<a class="anchor" name="09062203befa6bb1ad7db0537cba9dbc"></a><!-- doxytag: member="sm::eod::utils::eulerAnglesToRotationMatrix" ref="09062203befa6bb1ad7db0537cba9dbc" args="(const fStdVector3 &amp;euler_angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;float&gt; &gt; sm::eod::utils::eulerAnglesToRotationMatrix           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>euler_angles</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from a set of euler angles to a 3x3 rotation matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>euler_angles</em>&nbsp;</td><td>The three euler angles defining the rotation. Assumes that the order of rotation around the axes is [X, Y, Z] </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>3x3 rotation matrix defining the rotation. When accessing this matrix, the first index is the row index, the second is the column index </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>euler_angles must be in 3 dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="59ad083417373e086ee93ca208c6b82f"></a><!-- doxytag: member="sm::eod::utils::frameNumber" ref="59ad083417373e086ee93ca208c6b82f" args="(const EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html#b4a855ab0be6004dd4e37af0606881fb">EngineOutputData::FrameNumber</a> sm::eod::utils::frameNumber           </td>
          <td>(</td>
          <td class="paramtype">const EngineOutputData &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the frame number of the data </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="f64c7820dac7832041ec67aae188b852"></a><!-- doxytag: member="sm::eod::utils::fromEulerAngles" ref="f64c7820dac7832041ec67aae188b852" args="(const dStdVector3 &amp;euler_angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesm_1_1eod.html#7fd9102b624957cdd32629d206faa8e9">dStdVector4</a> sm::eod::utils::fromEulerAngles           </td>
          <td>(</td>
          <td class="paramtype">const dStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>euler_angles</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a quaternion from a vector containing euler angles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>euler_angles</em>&nbsp;</td><td>in the convention XYZ </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Quaternion [q0, q1, q2, q3] </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>euler angle must be of 3 dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b36da673b2cf8a78d3eb5ced1d20fb7"></a><!-- doxytag: member="sm::eod::utils::gazeVergenceAngle" ref="4b36da673b2cf8a78d3eb5ced1d20fb7" args="(const sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::gazeVergenceAngle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2aba5c1caead40163b7857a712e4c76"></a><!-- doxytag: member="sm::eod::utils::gazeVergenceAngle" ref="a2aba5c1caead40163b7857a712e4c76" args="(sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::gazeVergenceAngle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the vergence angle between the gaze rays </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>gaze data must be present and the gaze quality for both eyes must be atleast IR_GAZE level </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if the gaze rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d527bdf75162449ab99b11afdd4ed3b0"></a><!-- doxytag: member="sm::eod::utils::gazeVergenceDistance" ref="d527bdf75162449ab99b11afdd4ed3b0" args="(const sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::gazeVergenceDistance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="550caa8097e6761782cef9bc0a254b8b"></a><!-- doxytag: member="sm::eod::utils::gazeVergenceDistance" ref="550caa8097e6761782cef9bc0a254b8b" args="(sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::gazeVergenceDistance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the vergence distance - distance between the HeadPose origin and vergence point </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>gaze data must be present and the gaze quality for both eyes must be atleast IR_GAZE level </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if the gaze rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5b888a3ce0e071680e63fa5a79b07a93"></a><!-- doxytag: member="sm::eod::utils::gazeVergencePoint" ref="5b888a3ce0e071680e63fa5a79b07a93" args="(const sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::gazeVergencePoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="354de619cae8e28a6ed28b260e9c7a0e"></a><!-- doxytag: member="sm::eod::utils::gazeVergencePoint" ref="354de619cae8e28a6ed28b260e9c7a0e" args="(sm::eod::EngineOutputData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::gazeVergencePoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the vergence point of the gaze rays if they intersect, or the mid-point of the line joining the points where the rays are closest to each other </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>gaze data must be present and the gaze quality for both eyes must be atleast IR_GAZE level </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if the gaze rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b920c3f69553c65a8ba4eccfff14d1d6"></a><!-- doxytag: member="sm::eod::utils::innerProduct" ref="b920c3f69553c65a8ba4eccfff14d1d6" args="(const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::innerProduct           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The inner product of the two direction vectors </dd></dl>

<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vectors must have the same number of dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="35a932c49a35d08f510ec833536abcb6"></a><!-- doxytag: member="sm::eod::utils::isTracking" ref="35a932c49a35d08f510ec833536abcb6" args="(sm::eod::EngineOutputData &amp;eod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sm::eod::utils::isTracking           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>eod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the head is tracking </dd></dl>

<p>
Note this used to also check EngineOutputData::dssOutputDataV2(). As that class has been split into the DSS DATA API the behaviour of this function has changed. <dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use eod-&gt;<a class="el" href="namespacesm_1_1eod.html#992f781028939b8277987f29584bd01f">headOutputData()</a>-&gt;<a class="el" href="namespacesm_1_1eod_1_1utils.html#35a932c49a35d08f510ec833536abcb6">isTracking()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a31b6978f9f135e1b768de30cd4aa10"></a><!-- doxytag: member="sm::eod::utils::length" ref="3a31b6978f9f135e1b768de30cd4aa10" args="(const std::vector&lt; float &gt; &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::length           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Cartesian length of a vector </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="c758cfda1eb8caa7f77103db8a0c076a"></a><!-- doxytag: member="sm::eod::utils::mergedGazeRay" ref="c758cfda1eb8caa7f77103db8a0c076a" args="(const sm::eod::EngineOutputData &amp;data, fStdVector3 &amp;ray_origin, fStdVector3 &amp;ray_direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm::eod::utils::mergedGazeRay           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use non-const version </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa4cdc2800eb7315f15cbde1f628b1c9"></a><!-- doxytag: member="sm::eod::utils::mergedGazeRay" ref="aa4cdc2800eb7315f15cbde1f628b1c9" args="(sm::eod::EngineOutputData &amp;data, fStdVector3 &amp;ray_origin, fStdVector3 &amp;ray_direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm::eod::utils::mergedGazeRay           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">sm::eod::EngineOutputData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a merged gaze ray. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td><a class="el" href="classsm_1_1eod_1_1_engine_output_data.html">EngineOutputData</a> to extract the gaze rays from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ray_origin</em>&nbsp;</td><td>Receives the origin of the merged gaze ray in world co-ordinates [X, Y, Z]. This is always the head-pose origin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ray_direction</em>&nbsp;</td><td>Receives the direction of the merged gaze ray in world co-ordinates [X, Y, Z] This is an angular average between the gaze vectors from each eye </td></tr>
  </table>
</dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>gaze data must be present and at least one eye must have a gaze quality level greater than NO_TRACKING </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_output_data_utils_error.html">OutputDataUtilsError</a></em>&nbsp;</td><td>if no gaze data could be computed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="006cef3006962e26346539e576ee9d2e"></a><!-- doxytag: member="sm::eod::utils::operator *" ref="006cef3006962e26346539e576ee9d2e" args="(float factor, const std::vector&lt; float &gt; &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; sm::eod::utils::operator *           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scalar-vector multiplication operator for STL vectors of float. 
<p>

</div>
</div><p>
<a class="anchor" name="080d6a608ee93d86cfc0447f928bf613"></a><!-- doxytag: member="sm::eod::utils::operator+" ref="080d6a608ee93d86cfc0447f928bf613" args="(const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; sm::eod::utils::operator+           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Addition operator for STL vectors of float. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vectors must have the same number of dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e2a588ccfbf3edf9a256ac6b8a0df8c"></a><!-- doxytag: member="sm::eod::utils::operator-" ref="6e2a588ccfbf3edf9a256ac6b8a0df8c" args="(const std::vector&lt; float &gt; &amp;direction1, const std::vector&lt; float &gt; &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; sm::eod::utils::operator-           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtraction operator for STL vectors of float. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vectors must have the same number of dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="1431e95fd081fe9f95f368845e533940"></a><!-- doxytag: member="sm::eod::utils::operator-" ref="1431e95fd081fe9f95f368845e533940" args="(const std::vector&lt; float &gt; &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; sm::eod::utils::operator-           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unary inversion operator for STL vectors of float. 
<p>

</div>
</div><p>
<a class="anchor" name="59f41b5772abf4cf0dafb67ba89a9a61"></a><!-- doxytag: member="sm::eod::utils::pitchYawFromDirection" ref="59f41b5772abf4cf0dafb67ba89a9a61" args="(const fStdVector3 &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#839d4aba62f000fcedbad80d71f505d7">fStdVector2</a> sm::eod::utils::pitchYawFromDirection           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the 3D direction vector [X, Y, Z] <em>direction</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>Direction vector in some coordinate </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this function always uses the negative z convention </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vector must be in 3 dimensions </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c262f203be61a78d049717d1b21b30f"></a><!-- doxytag: member="sm::eod::utils::pointsOfRaysClosestApproach" ref="9c262f203be61a78d049717d1b21b30f" args="(const fStdVector3 &amp;origin1, const fStdVector3 &amp;direction1, const fStdVector3 &amp;origin2, const fStdVector3 &amp;direction2, fStdVector3 &amp;closest_point1_out, fStdVector3 &amp;closest_point2_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm::eod::utils::pointsOfRaysClosestApproach           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>closest_point1_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>closest_point2_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the points of closest approach on the rays. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>origin1</em>&nbsp;</td><td>The origin of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction1</em>&nbsp;</td><td>The direction vector of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin2</em>&nbsp;</td><td>The origin of the second ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction2</em>&nbsp;</td><td>The direction vector of the second ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closest_point1_out</em>&nbsp;</td><td>Returns the closest point on ray1 to ray2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closest_point2_out</em>&nbsp;</td><td>Returns the closest point on ray2 to ray1 </td></tr>
  </table>
</dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>origin1, direction1, origin2, direction2 must be in 3 dimensions </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html">GeomUtilsError</a></em>&nbsp;</td><td>if the two rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3120e842481fda5b1f0d8131448808a4"></a><!-- doxytag: member="sm::eod::utils::rayIntersectionPoint" ref="3120e842481fda5b1f0d8131448808a4" args="(const fStdVector3 &amp;origin1, const fStdVector3 &amp;direction1, const fStdVector3 &amp;origin2, const fStdVector3 &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::rayIntersectionPoint           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>origin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the intersection of two rays, or the point in the middle between the two closest points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>origin1</em>&nbsp;</td><td>The origin of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction1</em>&nbsp;</td><td>The direction vector of the first ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin2</em>&nbsp;</td><td>The origin of the second ray [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction2</em>&nbsp;</td><td>The direction vector of the second ray [X, Y, Z] </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the 3D intersection point, or the point in the middle of the line joining the closest points on each ray </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>origin1, direction1, origin2, direction2 must be in 3 dimensions </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html">GeomUtilsError</a></em>&nbsp;</td><td>if the two rays are parallel </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0c37825beb7a2ef090965dd27708037"></a><!-- doxytag: member="sm::eod::utils::rayPlaneIntersect" ref="a0c37825beb7a2ef090965dd27708037" args="(const fStdVector3 &amp;ray_origin, const fStdVector3 &amp;direction, const fStdVector3 &amp;plane_top_left, const fStdVector3 &amp;plane_top_right, const fStdVector3 &amp;plane_bottom_left, fStdVector2 &amp;plane_intersect, fStdVector3 &amp;world_intersect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sm::eod::utils::rayPlaneIntersect           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>plane_top_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>plane_top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>plane_bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector2 &amp;&nbsp;</td>
          <td class="paramname"> <em>plane_intersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>world_intersect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the point where a ray intersects with a plane. 
<p>
The plane is defined by three corner points (top-left, top_right and bottom-left). These points define the coordinate frame of the plane. The origin is at the top-left corner. The positive x axis points from the origin towards the top-right corner. The positive y axis points from the origin towards the bottom-left corner. The coordinate values are normalised, so that the top-right corner is at (1, 0), and the bottom-left corner is at (0, 1). <dl class="note" compact><dt><b>Note:</b></dt><dd>This function will report a plane intersection even if the intersection point is not within the boundaries defined by the three corner points. To check if the intersection occurs within the boundaries of the three corner points, check if the plane_intersect value is within the rectangle defined by (0, 0), (0, 1), (1, 0), (1, 1). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ray_origin</em>&nbsp;</td><td>Origin of the ray in world coordinates [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>Direction vector of the ray in world coordinates [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane_top_left</em>&nbsp;</td><td>top-left-hand corner of the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane_top_right</em>&nbsp;</td><td>top-right-hand corner of the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane_bottom_left</em>&nbsp;</td><td>bottom_left-hand corner of the plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane_intersect</em>&nbsp;</td><td>Receives the intersection point in normalised plane coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>world_intersect</em>&nbsp;</td><td>Recieves the intersection point in world coordinates </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the ray intersects the plane, false otherwise. A ray does not intersect the plane if it is parallel, or if its direction vector points away from the plane </dd></dl>

</div>
</div><p>
<a class="anchor" name="04bd1028b33e36cd2e4e921072ad1064"></a><!-- doxytag: member="sm::eod::utils::rotMatrixToDirection" ref="04bd1028b33e36cd2e4e921072ad1064" args="(std::vector&lt; std::vector&lt; float &gt; &gt; rotation_matrix, Direction dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; sm::eod::utils::rotMatrixToDirection           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>rotation_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the direction vector for an axis from the rotation matrix. 
<p>
This is the direction of the <em>dir</em> axis rotated by <em>rotation_matrix</em> <dl class="note" compact><dt><b>Note:</b></dt><dd>the indexes of rotation_matrix assume that the first index refers to the row, the second index to the column </dd></dl>

</div>
</div><p>
<a class="anchor" name="f62f0e544cdf38384157b6cb44db8ee3"></a><!-- doxytag: member="sm::eod::utils::rotMatrixToEulerAngles" ref="f62f0e544cdf38384157b6cb44db8ee3" args="(const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;rotation_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesm_1_1eod.html#39fe4d8d39cadce823e21c893cea0413">fStdVector3</a> sm::eod::utils::rotMatrixToEulerAngles           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rotation_matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from a 3x3 rotation matrix to a set of euler angles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rotation_matrix</em>&nbsp;</td><td>3x3 rotation matrix defining the rotation. The first index of the matrix should be the row index, the second is the column index </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The vector of three euler angles defining the rotation. The order of rotation around the axes is [X, Y, Z] </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>rotation matrix must be 3x3 </dd></dl>

</div>
</div><p>
<a class="anchor" name="90c052ce38c95701b22cc301b3ba1854"></a><!-- doxytag: member="sm::eod::utils::toEulerAngles" ref="90c052ce38c95701b22cc301b3ba1854" args="(const dStdVector4 &amp;quaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesm_1_1eod.html#8f3c6523d26c72f00fd9c0e2319274a0">dStdVector3</a> sm::eod::utils::toEulerAngles           </td>
          <td>(</td>
          <td class="paramtype">const dStdVector4 &amp;&nbsp;</td>
          <td class="paramname"> <em>quaternion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a quaternion from a vector containing quaternion components. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>quaternion</em>&nbsp;</td><td>components in the convention [q0, q1, q2, q3] </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The euler_angles in the convention XYZ </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>quaternion must have 4 elements </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca63a036ef1dedbbf36070bcfa108ca8"></a><!-- doxytag: member="sm::eod::utils::unitVector" ref="ca63a036ef1dedbbf36070bcfa108ca8" args="(const std::vector&lt; float &gt; &amp;direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; sm::eod::utils::unitVector           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unit vector. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The normalized vector of a given vector </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction has a length 0.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="dcbb94eeb4dd82aaaedf6833bab656b6"></a><!-- doxytag: member="sm::eod::utils::vectorIntersectionAngle" ref="dcbb94eeb4dd82aaaedf6833bab656b6" args="(const fStdVector3 &amp;direction1, const fStdVector3 &amp;direction2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sm::eod::utils::vectorIntersectionAngle           </td>
          <td>(</td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fStdVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>direction2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the angle between two direction vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction1</em>&nbsp;</td><td>First direction vector [X, Y, Z] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction2</em>&nbsp;</td><td>Second direction vector [X, Y, Z] </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this angle is always positive. It is not signed </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The angle between the two vectors (in radians) </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>direction vectors must be in 3 dimensions </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classsm_1_1eod_1_1utils_1_1_geom_utils_error.html">GeomUtilsError</a></em>&nbsp;</td><td>if one of the vectors is of length 0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ed0485076d58a6953f8afb321689cf3d"></a><!-- doxytag: member="sm::eod::utils::MAX_GAZE_VERGENCE_DISTANCE" ref="ed0485076d58a6953f8afb321689cf3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float <a class="el" href="namespacesm_1_1eod_1_1utils.html#ed0485076d58a6953f8afb321689cf3d">MAX_GAZE_VERGENCE_DISTANCE</a> = 1.5f          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum gaze ray vergence distance in meters. 
<p>
If the vergence distance is larger, gaze rays will be considered to be parallel. 
<p>
Definition at line <a class="el" href="outputdatautils_8h-source.html#l00114">114</a> of file <a class="el" href="outputdatautils_8h-source.html">outputdatautils.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri Apr 1 15:36:52 2011 for Seeing Machines CoreData API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.0 </small></address>
</body>
</html>
