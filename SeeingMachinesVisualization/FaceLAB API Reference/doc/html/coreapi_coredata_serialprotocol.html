<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Seeing Machines CoreData API: CoreData Serial Protocol</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.0 -->
<h1><a class="anchor" name="coreapi_coredata_serialprotocol">CoreData Serial Protocol</a></h1><dl class="user" compact><dt><b></b></dt><dd><a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_intro">1. Introduction</a><br>
 <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_cable">2. Serial Cable</a><br>
 <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_config">3. Serial Port Configuration</a><br>
 <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_byteseq">4. Frame Byte Sequence</a><br>
  &nbsp;&nbsp;&nbsp;  <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_byteseq_startstop">4.1 Frame Start / Stop Flag</a><br>
  &nbsp;&nbsp;&nbsp;  <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_byteseq_bytestuffing">4.2 Byte Stuffing</a><br>
  &nbsp;&nbsp;&nbsp;  <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_byteseq_crc">4.3 CRC-16 Error Detection</a><br>
 <a class="el" href="coreapi_coredata_serialprotocol.html#coreapi_coredata_serialprotocol_reference">5. Reference</a><br>
</dd></dl>
<hr>
 <h2><a class="anchor" name="coreapi_coredata_serialprotocol_intro">
1. Introduction</a></h2>
This page describes the CoreData serial connection protocol. To receive CoreData data through a serial connection on an unsupported platform, or by developing your own C code, you will need to understand the protocol used for serial transmission.<p>
<hr>
 <h2><a class="anchor" name="coreapi_coredata_serialprotocol_cable">
2. Serial Cable</a></h2>
A 3-wire RS-232 NULL modem cable is all that is needed.<p>
<hr>
 <h2><a class="anchor" name="coreapi_coredata_serialprotocol_config">
3. Serial Port Configuration</a></h2>
Serial ports must be configured to:<ul>
<li>115200 baud</li><li>8 data bits</li><li>1 stop bit</li><li>No flow control or handshaking</li><li>No parity</li></ul>
<p>
<hr>
 <h2><a class="anchor" name="coreapi_coredata_serialprotocol_byteseq">
4. Frame Byte Sequence</a></h2>
CoreData serial data is transmitted in frames, each frame containing the data for a single EngineOutputData class.<p>
The frame byte sequence is described by the following diagram:<p>
<div align="center">
<img src="serialprotocol_small.png" alt="serialprotocol_small.png">
<p><strong>Figure 1: CoreData Serial Protocol - Frame Byte Sequence</strong></p></div>
<h3><a class="anchor" name="coreapi_coredata_serialprotocol_byteseq_startstop">
4.1	Frame Start / Stop Flag</a></h3>
The sequence of bytes receives from the serial connection, can be resolved into a sequence of frames, by listening for a pair of frame separator flag byte sequence. The separator flag consists of a 2-byte sequence 0xAA 0x55 (hexadecimal byte values). All frames begin and end with this 2-byte sequence.<h3><a class="anchor" name="coreapi_coredata_serialprotocol_byteseq_bytestuffing">
4.2	Byte Stuffing</a></h3>
To avoid errors when the packet data contains the frame flag byte sequence, every 0xAA in the data has a 0x00 inserted after it (including the checksums). These “stuffed” bytes must be detected during frame reception and removed.<h3><a class="anchor" name="coreapi_coredata_serialprotocol_byteseq_crc">
4.3	CRC-16 Error Detection</a></h3>
To ensure reliable transmission in a noisy environment, a CRC-16 checksum is calculated from the data (before stuffing occurs), and is then appended to the data. To check for errors when receiving a packet, first “unstuff” the data sequence, and then compute the CRC-16 checksum over the entire data sequence, including the CRC bytes. If the computed checksum is 0, then no errors have occurred. You can then discard the last 2 bytes of the sequence (the checksum). Refer to the methods SerialPort::makeCRC() and SerialPort::checkCRC()<p>
<hr>
 <h2><a class="anchor" name="coreapi_coredata_serialprotocol_reference">
5. Reference</a></h2>
<ul>
<li><a class="el" href="coreapi_coredata_binary_standard.html">CoreData Binary Standard</a>.</li><li><a class="el" href="coreapi_coredata_cpp_main.html">CoreData C++ API</a></li><li><a class="el" href="classsm_1_1eod_1_1io_1_1_serial_port.html#c21c526d0ff965acad36fbc21a24076c">sm::eod::io::SerialPort::receiveDatagram()</a> source code for further details on the frame byte sequence. </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Apr 1 15:36:50 2011 for Seeing Machines CoreData API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.0 </small></address>
</body>
</html>
